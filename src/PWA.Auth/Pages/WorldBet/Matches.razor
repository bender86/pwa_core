@page "/worldbet/matches"
@using PWA.Auth.Pages.WorldBet.Shared
@using dto.worldbet.Models
@using dto.worldbet.Requests
@using dto.worldbet.Enums
@layout WorldBetLayout
@inject ITournamentService TournamentService
@inject IPronosticService PronosticService
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthStateProvider
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@attribute [Authorize]

<PageTitle>Matches</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <div class="d-flex justify-content-between align-items-center mb-4 flex-wrap gap-2">
        <MudText Typo="Typo.h4">üèÜ Matches du Tournoi</MudText>
        @if (isAdmin)
        {
            <MudButton Variant="Variant.Filled" 
                       Color="Color.Primary" 
                       StartIcon="@Icons.Material.Filled.Add"
                       OnClick="ShowCreateModal">
                Cr√©er un Match
            </MudButton>
        }
    </div>

    @if (isLoading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
    }
    else
    {
        <MudDataGrid T="MatchDto" 
                     Items="@filteredMatches" 
                     Dense="true" 
                     Hover="true"
                     Bordered="true" 
                     Striped="true" 
                     Filterable="false"
                     SortMode="SortMode.Multiple"
                     QuickFilter="@QuickFilter"
                     Class="mb-4">
            <ToolBarContent>
                <MudText Typo="Typo.h6">Liste des Matches</MudText>
                <MudSpacer />
                
                <!-- Phase Filter -->
                <MudSelect T="string" 
                           Value="@filterPhase"
                           ValueChanged="@((string value) => { filterPhase = value; FilterMatches(); })"
                           Label="Phase" 
                           Variant="Variant.Outlined"
                           Margin="Margin.Dense"
                           Class="filter-select"
                           Clearable="true"
                           AdornmentIcon="@Icons.Material.Filled.FilterList">
                    @foreach (var phase in allPhases)
                    {
                        <MudSelectItem Value="@phase.Name">@phase.Name</MudSelectItem>
                    }
                </MudSelect>

                <!-- Group Filter -->
                <MudSelect T="string" 
                           Value="@filterGroup"
                           ValueChanged="@((string value) => { filterGroup = value; FilterMatches(); })"
                           Label="Groupe" 
                           Variant="Variant.Outlined"
                           Margin="Margin.Dense"
                           Class="filter-select ms-2"
                           Clearable="true"
                           AdornmentIcon="@Icons.Material.Filled.Groups">
                    @foreach (var group in availableGroups)
                    {
                        <MudSelectItem Value="@group">Groupe @group</MudSelectItem>
                    }
                </MudSelect>

                <!-- Status Filter -->
                <MudSelect T="string" 
                           Value="@filterStatus"
                           ValueChanged="@((string value) => { filterStatus = value; FilterMatches(); })"
                           Label="Statut" 
                           Variant="Variant.Outlined"
                           Margin="Margin.Dense"
                           Class="filter-select ms-2"
                           Clearable="true"
                           AdornmentIcon="@Icons.Material.Filled.Flag">
                    <MudSelectItem Value="@nameof(MatchStatus.Scheduled)">Programm√©</MudSelectItem>
                    <MudSelectItem Value="@nameof(MatchStatus.Live)">En cours</MudSelectItem>
                    <MudSelectItem Value="@nameof(MatchStatus.Finished)">Termin√©</MudSelectItem>
                    <MudSelectItem Value="@nameof(MatchStatus.Postponed)">Report√©</MudSelectItem>
                </MudSelect>

                <!-- Search -->
                <MudTextField @bind-Value="searchString" 
                              Placeholder="Rechercher..." 
                              Adornment="Adornment.Start" 
                              AdornmentIcon="@Icons.Material.Filled.Search"
                              IconSize="Size.Medium" 
                              Variant="Variant.Outlined"
                              Margin="Margin.Dense"
                              Class="ms-2" 
                              Immediate="true" />
            </ToolBarContent>
            
            <Columns>
                <!-- Date -->
                <PropertyColumn Property="x => x.ScheduledDate" Title="Date" Sortable="true">
                    <CellTemplate>
                        <MudText Typo="Typo.body2">
                            @context.Item.ScheduledDate.ToString("dd/MM/yyyy")
                            <br />
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                @context.Item.ScheduledDate.ToString("HH:mm")
                            </MudText>
                        </MudText>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Phase -->
                <PropertyColumn Property="x => x.PhaseName" Title="Phase" Sortable="true">
                    <CellTemplate>
                        <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Outlined">
                            @context.Item.PhaseName
                        </MudChip>
                    </CellTemplate>
                </PropertyColumn>

                <!-- Group -->
                <TemplateColumn Title="Groupe" Sortable="false">
                    <CellTemplate>
                        @if (!string.IsNullOrEmpty(context.Item.GroupLetter))
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Secondary">
                                @context.Item.GroupLetter
                            </MudChip>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Tertiary">-</MudText>
                        }
                    </CellTemplate>
                </TemplateColumn>

                <!-- Match -->
                <TemplateColumn Title="Match" Sortable="false">
                    <CellTemplate>
                        <div class="d-flex flex-column">
                            <MudText Typo="Typo.body1" Class="font-weight-bold">
                                @context.Item.Team1Name
                            </MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">vs</MudText>
                            <MudText Typo="Typo.body1" Class="font-weight-bold">
                                @context.Item.Team2Name
                            </MudText>
                        </div>
                    </CellTemplate>
                </TemplateColumn>

                <!-- Score -->
                <TemplateColumn Title="Score" Sortable="false">
                    <CellTemplate>
                        @if (context.Item.ScoreTeam1.HasValue && context.Item.ScoreTeam2.HasValue)
                        {
                            <MudChip T="string" Color="Color.Success" Size="Size.Medium">
                                <strong>@context.Item.ScoreTeam1 - @context.Item.ScoreTeam2</strong>
                            </MudChip>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Tertiary">- vs -</MudText>
                        }
                    </CellTemplate>
                </TemplateColumn>

                <!-- Mon Prono -->
                <TemplateColumn Title="Mon Prono" Sortable="false">
                    <CellTemplate>
                        @if (userPronostics.TryGetValue(context.Item.MatchId, out var prono))
                        {
                            <MudChip T="string" Color="Color.Warning" Size="Size.Small" Icon="@Icons.Material.Filled.Bolt">
                                @prono.PredictedScoreTeam1 - @prono.PredictedScoreTeam2
                            </MudChip>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Color="Color.Tertiary">-</MudText>
                        }
                    </CellTemplate>
                </TemplateColumn>

                <!-- Status -->
                <TemplateColumn Title="Statut" Sortable="true">
                    <CellTemplate>
                        <MudChip T="string" Color="@GetStatusMudColor(context.Item.Status)" Size="Size.Small">
                            @GetStatusLabel(context.Item.Status)
                        </MudChip>
                    </CellTemplate>
                </TemplateColumn>

                <!-- Actions -->
                <TemplateColumn Title="Actions" Sortable="false" Filterable="false">
                    <CellTemplate>
                        <div class="d-flex gap-1">
                            <!-- Pronostic button (for all users) -->
                            <PronosticButton Match="@context.Item"
                                           HasPronostic="@userPronostics.ContainsKey(context.Item.MatchId)"
                                           Size="Small"
                                           OnPronosticSaved="@HandlePronosticSavedInGrid" />

                            <!-- Admin actions -->
                            @if (isAdmin)
                            {
                                <MudTooltip Text="Modifier">
                                    <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                                   Color="Color.Primary"
                                                   Size="Size.Small"
                                                   OnClick="@(() => EditMatch(context.Item))" />
                                </MudTooltip>
                                <MudTooltip Text="Supprimer">
                                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                                   Color="Color.Error"
                                                   Size="Size.Small"
                                                   OnClick="@(() => ConfirmDelete(context.Item))" />
                                </MudTooltip>
                            }
                        </div>
                    </CellTemplate>
                </TemplateColumn>
            </Columns>
            
            <PagerContent>
                <MudDataGridPager T="MatchDto" />
            </PagerContent>

            <NoRecordsContent>
                <MudText Typo="Typo.body1" Align="Align.Center" Class="py-4">
                    <MudIcon Icon="@Icons.Material.Filled.Info" Class="me-2" />
                    Aucun match trouv√© avec ces crit√®res.
                </MudText>
            </NoRecordsContent>
        </MudDataGrid>
    }
</MudContainer>

<!-- Match Form Modal (Admin only) -->
<MatchFormModal @bind-IsVisible="showModal"
                Model="@currentRequest"
                Teams="@allTeams"
                Phases="@allPhases"
                IsLoading="@isSaving"
                ErrorMessage="@modalError"
                IsEditMode="@isEditMode"
                OnSubmit="SaveMatch"
                OnCancel="CloseModal" />

@code {
    // Dialog options
    private DialogOptions dialogOptions = new() { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };

    // User state
    private bool isAdmin = false;
    private Dictionary<int, PronosticDto> userPronostics = new();

    // Data
    private List<MatchDto> allMatches = new();
    private List<MatchDto> filteredMatches = new();
    private List<TeamDto> allTeams = new();
    private List<PhaseDto> allPhases = new();
    private List<string> availableGroups = new();
    
    // Loading states
    private bool isLoading = true;
    private bool isSaving = false;
    private bool isDeleting = false;
    
    // Filters
    private string filterPhase = "";
    private string filterGroup = "";
    private string filterStatus = "";
    private string searchString = "";
    
    // Modal states
    private bool showModal = false;
    private bool isEditMode = false;
    
    // Current data
    private CreateMatchRequest currentRequest = new();
    private int currentMatchId = 0;
    
    // Messages
    private string? modalError;
    
    protected override async Task OnInitializedAsync()
    {
        await CheckUserRole();
        await LoadAllData();
    }

    private async Task CheckUserRole()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        isAdmin = user.IsInRole("Admin");
    }
    
    private async Task LoadAllData()
    {
        isLoading = true;
        try
        {
            var matchesTask = TournamentService.GetAllMatchesAsync();
            var teamsTask = TournamentService.GetAllTeamsAsync();
            var phasesTask = TournamentService.GetAllPhasesAsync();
            var pronosticsTask = PronosticService.GetMyPronosticsAsync();
            
            await Task.WhenAll(matchesTask, teamsTask, phasesTask, pronosticsTask);
            
            allMatches = await matchesTask;
            allTeams = await teamsTask;
            allPhases = await phasesTask;
            
            var pronostics = await pronosticsTask;
            userPronostics = pronostics.ToDictionary(p => p.MatchId, p => p);

            availableGroups = allMatches
                .Where(m => !string.IsNullOrEmpty(m.GroupLetter))
                .Select(m => m.GroupLetter!)
                .Distinct()
                .OrderBy(g => g)
                .ToList();
            
            FilterMatches();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erreur lors du chargement : {ex.Message}", Severity.Error);
        }
        finally
        {
            isLoading = false;
        }
    }
    
    private void FilterMatches()
    {
        filteredMatches = allMatches.Where(m =>
            (string.IsNullOrEmpty(filterPhase) || m.PhaseName == filterPhase) &&
            (string.IsNullOrEmpty(filterGroup) || m.GroupLetter == filterGroup) &&
            (string.IsNullOrEmpty(filterStatus) || m.Status.ToString() == filterStatus)
        ).OrderBy(m => m.ScheduledDate).ToList();
    }

    private Func<MatchDto, bool> QuickFilter => x =>
    {
        if (string.IsNullOrWhiteSpace(searchString))
            return true;

        var search = searchString.ToLower();
        return x.Team1Name?.ToLower().Contains(search) == true
            || x.Team2Name?.ToLower().Contains(search) == true
            || x.PhaseName?.ToLower().Contains(search) == true;
    };

    private async Task HandlePronosticSavedInGrid(PronosticDto prono)
    {
        // Update local dictionary
        userPronostics[prono.MatchId] = prono;
        Snackbar.Add($"Pronostic enregistr√© : {prono.PredictedScoreTeam1}-{prono.PredictedScoreTeam2}", Severity.Success);
        StateHasChanged();
    }
    
    private void ShowCreateModal()
    {
        Console.WriteLine("ShowCreateModal called");
        if (!isAdmin)
        {
            Console.WriteLine("User is not admin, returning");
            return;
        }

        Console.WriteLine("Setting up create modal");
        var defaultDate = DateTime.Now.AddDays(1);
        currentRequest = new CreateMatchRequest
        {
            ScheduledDate = defaultDate,
            LockPronosticsAt = defaultDate.AddMinutes(-5),
            Status = MatchStatus.Scheduled
        };
        currentMatchId = 0;
        isEditMode = false;
        modalError = null;
        showModal = true;
        Console.WriteLine($"showModal set to: {showModal}");
        StateHasChanged();
    }
    
    private void EditMatch(MatchDto match)
    {
        Console.WriteLine("EditMatch called");
        if (!isAdmin)
        {
            Console.WriteLine("User is not admin, returning");
            return;
        }

        Console.WriteLine("Setting up edit modal");
        currentRequest = new CreateMatchRequest
        {
            PhaseId = match.PhaseId,
            Team1Id = match.Team1Id,
            Team2Id = match.Team2Id,
            ScheduledDate = match.ScheduledDate,
            Venue = match.Venue,
            MatchNumber = match.MatchNumber,
            GroupLetter = match.GroupLetter,
            ScoreTeam1 = match.ScoreTeam1,
            ScoreTeam2 = match.ScoreTeam2,
            Status = match.Status,
            LockPronosticsAt = match.LockPronosticsAt
        };
        currentMatchId = match.MatchId;
        isEditMode = true;
        modalError = null;
        showModal = true;
        Console.WriteLine($"showModal set to: {showModal}");
        StateHasChanged();
    }
    
    private async Task SaveMatch()
    {
        if (!isAdmin) return;

        isSaving = true;
        modalError = null;
        
        try
        {
            if (isEditMode)
            {
                var updateRequest = new UpdateMatchRequest
                {
                    PhaseId = currentRequest.PhaseId,
                    Team1Id = currentRequest.Team1Id,
                    Team2Id = currentRequest.Team2Id,
                    ScheduledDate = currentRequest.ScheduledDate,
                    Venue = currentRequest.Venue,
                    MatchNumber = currentRequest.MatchNumber,
                    GroupLetter = currentRequest.GroupLetter,
                    ScoreTeam1 = currentRequest.ScoreTeam1,
                    ScoreTeam2 = currentRequest.ScoreTeam2,
                    Status = currentRequest.Status,
                    LockPronosticsAt = currentRequest.LockPronosticsAt
                };
                
                await TournamentService.UpdateMatchAsync(currentMatchId, updateRequest);
                Snackbar.Add("Match modifi√© avec succ√®s !", Severity.Success);
            }
            else
            {
                await TournamentService.CreateMatchAsync(currentRequest);
                Snackbar.Add("Match cr√©√© avec succ√®s !", Severity.Success);
            }
            
            await LoadAllData();
            CloseModal();
        }
        catch (Exception ex)
        {
            modalError = $"Erreur : {ex.Message}";
        }
        finally
        {
            isSaving = false;
        }
    }
    
    private async Task ConfirmDelete(MatchDto match)
    {
        if (!isAdmin) return;

        bool? result = await DialogService.ShowMessageBox(
            "Confirmer la suppression",
            $"√ätes-vous s√ªr de vouloir supprimer ce match ?\n\n{match.Team1Name} vs {match.Team2Name}\n{match.ScheduledDate:dd/MM/yyyy HH:mm}\n\n‚ö†Ô∏è Cette action est irr√©versible.",
            yesText: "Supprimer",
            cancelText: "Annuler");

        if (result == true)
        {
            await DeleteMatchConfirmed(match.MatchId);
        }
    }
    
    private async Task DeleteMatchConfirmed(int matchId)
    {
        if (!isAdmin) return;
        
        isDeleting = true;
        try
        {
            var success = await TournamentService.DeleteMatchAsync(matchId);
            
            if (success)
            {
                Snackbar.Add("Match supprim√© avec succ√®s !", Severity.Success);
                await LoadAllData();
            }
            else
            {
                Snackbar.Add("Match introuvable.", Severity.Error);
            }
        }
        catch (InvalidOperationException ex)
        {
            Snackbar.Add(ex.Message, Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erreur lors de la suppression : {ex.Message}", Severity.Error);
        }
        finally
        {
            isDeleting = false;
        }
    }
    
    private void CloseModal()
    {
        showModal = false;
        currentRequest = new();
        currentMatchId = 0;
        modalError = null;
    }
    
    private Color GetStatusMudColor(MatchStatus status) => status switch
    {
        MatchStatus.Scheduled => Color.Default,
        MatchStatus.Live => Color.Success,
        MatchStatus.Finished => Color.Primary,
        MatchStatus.Postponed => Color.Warning,
        _ => Color.Default
    };
    
    private string GetStatusLabel(MatchStatus status) => status switch
    {
        MatchStatus.Scheduled => "Programm√©",
        MatchStatus.Live => "En cours",
        MatchStatus.Finished => "Termin√©",
        MatchStatus.Postponed => "Report√©",
        _ => status.ToString()
    };
}

<style>
    .filter-select {
        min-width: 150px;
    }

    .score-input input {
        text-align: center;
        font-size: 2rem;
        font-weight: bold;
    }

    @@media (max-width: 768px) {
        .filter-select {
            min-width: 100%;
            margin-bottom: 0.5rem;
        }

        .score-input input {
            font-size: 1.5rem;
        }
    }
</style>